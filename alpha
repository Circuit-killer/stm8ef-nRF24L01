\ A barebones nRF24L01 library for STM8 barebones breakout board

\ The nRF24L01 registers are 8 bits and data is in multiples of 8 bits
\ So two words R@ and R! will be used to fetch an 8 bit register and store it back as needed
\ I simply use pipe 0 ignoring the other pipes
\ I used the 5 byte address $E7 D8 C9 B0 A1
\ and left everything at default where possible

\ Hardware
\ connected via SPI
\ the pin _CSN is a chip select not pin. ie active low Must be manually set before SPI tries talking ot nRF24 chip
\ _CE is chip enable pin on nrf24. active low
\ _IRQ active low interrupt pin
\ this code at present polls the interrupts

\ some influence from an amForth library
\ eg _CE where the underscore signifies a pin defined as _CE on the micro. 
\ used some code from Eelco's io.fs to set up pins as outputs

\ since I don't use linux I can't use e4thcom. So I manualy load dependencies or include them in this file

_nRF24L01_
marker _nRF24L01_

#require spi.fs
#require io.fs


\ define the pins we need on micro

: _CSN $32 ; \ pin _CSN on nRF24L01 connected to port D2
: _CE  $33 ; \ pin _CE on nRF24L01 connected to port D3
: _IRQ $24 ; \ pin _IRQ on nRF24L01 connected to port C4

: setup_pins
   omode-pp _csn io-mode!
   omode-pp _ce io-mode!
   IMODE-FLOAT _IRQ io-mode!
   ;
        
\ define some constants for registers and bits we use

: R.CONFIG $00 ;
: R.STATUS $07 ;
: R.OBSERVE_TX $08 ;
: R.RX_ADDR_P0 $0A ;
: R.TX_ADDR $10 ;
: R.RX_PW_P0 $11 ;

\ the datasheet uses the notation that Bit 1 is 0b00000010 and I normally think of bit1 being 0b00000001
\ so I define Bit1 to Bit8 to avoid having to remember the datasheet representation
\ Confused? Clearly I am.

: Bit0 $1 ;
: Bit1 $2 ;
: Bit2 $4 ;
: Bit3 $8 ;
: Bit4 $16 ;
: Bit5 $32 ;
: Bit6 $64 ;
: Bit7 $128 ;

: Addr1 $E7 ;
: Addr2 $D8 ;
: Addr3 $C9 ;
: Addr4 $B0 ;
: Addr5 $A1 ;

: P0_width 11 ; \ bytes in a payload

VARIABLE timer
VARIABLE count \ for test purposes


: tSet TIM 500 + timer ! ; \ need to test if 500 is correct delay
: tTest TIM timer @ - 0 < ;
: delay130us tSet begin ttest until ;

: high ( pin --- )
   1 swap io! ;
: low 0 swap io! ;
   
: R@_ ( c1 --- ) \ prepare to receive
    _ce low
    _csn low
    spi status !    \ returns status register
   ;
: R@ ( c1 --- c2 ) \ fetch the contents of register c1
    R@_
    -1 spi  \ now return byte
    _csn high
;
: R!_ \ factored starting seq
   Pwr.Dn
   001000000 OR
   _csn low
   spi   status ! \ returns status register while sending C1
   ;
: R!0 ( C1 --- )
   R!_
   _csn high
;
: RX_DR.clear  \  clear data ready Int. flag
   R.status R@
   bit6 and
   Rstatus
   R!0
   ;
: R@n ( c2 c1 --- cN..C1 ) \ read c2 bytes
   R@_
   0 do
      -1 spi drop
   loop
   RX_DR.clear
   _csn high
   ;
: R!1 ( c2 c1 --- ) \ store c2 into register c1
   R!_
   spi  drop  \ ignore what is returned while sending C2
   _csn high
;
: R!2 ( c3 c2 c1 --- ) \ store c2 c3 into register c1
   R!_
   spi  drop  \ ignore what is returned while sending C2
   spi  drop  \ ignore what is returned while sending C3
   _csn high
;
: R!3 ( c4 c3 c2 c1 --- ) \ store c2 c3 c4 into register c1
   R!_
   spi  drop  \ ignore what is returned while sending C2
   spi  drop  \ ignore what is returned while sending C3
   spi  drop  \ ignore what is returned while sending C4
   _csn high
;
: R!4 ( c5 c4 c3 c2 c1 --- ) \ store 4 bytes into register c1
   R!_
   spi  drop  \ ignore what is returned while sending C2
   spi  drop  \ ignore what is returned while sending C3
   spi  drop  \ ignore what is returned while sending C4
   spi  drop  \ ignore what is returned while sending C5
   _csn high
;
: R!5 ( c6 c5 c4 c3 c2 c1 --- ) \ store c2 into register c1
   R!_
   spi  drop  \ ignore what is returned while sending C2
   spi  drop  \ ignore what is returned while sending C3
   spi  drop  \ ignore what is returned while sending C4
   spi  drop  \ ignore what is returned while sending C5
   spi  drop  \ ignore what is returned while sending C6
   _csn high
;
   
: >low ( c1 bitn ---- c2 ) \ set bitn low
   NOT AND
   ;
: >high ( c1 bitn ---- c2 ) set bitn high
   or
   ;
: 1#lshift
    1 swap lshift
;

\ Config register operations   

: Pwr.Up \ power RF24 up into standby mode
   R.Config R@
   Bit1 >high
   R.Config R!
   2ms   \ should be at least 1.5ms delay when powering up
   ;
: Pwr.Dn \ power down RF24
   R.Config R@
   Bit1 >low
   R.Config R!
   ;
: R.RX \ set RF24 to rx
   _ce high
   Pwr.Up
   R.Config R@
   Bit0 >high
   R.Config R!
   ;
: R.TX \ set RF24 to tx
   Pwr.Up
   R.Config R@
   Bit0 >low
   R.Config R!
   _ce high
   ;

\ status register
: Get_IRQ   \ RF24 has signalled IRQ, let's get it and see what it is
   R.Status R@
   ;
: RX_DR? 
   Get_IRQ
   Bit6 AND
   ;
: TX_DS?
   Get_IRQ
   Bit5 AND
   ;
: MAX_RT
   Get_IRQ
   Bit4 AND
   ;
: RX_P_NO
   Get_IRQ
   0b00001110 AND
   ;
: TX_Full?
   Get_IRQ
   bit0 AND
   ;


: FlushRx   $E2    
\ lets go use the nrf24L01
: SetAddress \ LSB first
   Addr5 R.RX_ADDR_P0 R!
   Addr4 R.RX_ADDR_P0 R!
   Addr3 R.RX_ADDR_P0 R!
   Addr2 R.RX_ADDR_P0 R!
   Addr1 R.RX_ADDR_P0 R!
   Addr5 R.TX_ADDR_P0 R!
   Addr4 R.TX_ADDR_P0 R!
   Addr3 R.TX_ADDR_P0 R!
   Addr2 R.TX_ADDR_P0 R!
   Addr1 R.TX_ADDR_P0 R!
;   
: SetPL_width
   P0_width R.RX_PW_P0 R!
   ;
: After_RST \ stuff we must do after a reset
   Pwr.Up  \ turn on 
   SetAddress
   SetPL_width
   Pwr.Dn
;
: R_RX_PAYLOAD \ returns n bytes as set by PO_width
   PO_width $61 R@n
   ;
: W_TX_PAYLOAD \ write n bytes as set by PO_width
   _csn low
   _ce low
   $A0 spi status ! \ tx conmand byte store status register
   PO_width 0 do
      spi drop
   loop             \ tx n bytes from stack
   _ce high
   delay130us     \ assumes RF24 was in standby mode
   _ce low          \ toggle to actually send packet
   _csn high
   ;

   : <incr ( a1 --- )
   dup @ 1+ swap !
   ;
: .HW
   72 101 108 108 111 32 87 111 114 108 100 \ "Hello World"
   W_TX_PAYLOAD
   500ms
;      
: Test_TX \ send "Hello World" 100 times
   R.TX
   0 count !
   begin
      count <incr
      .HW
      count @ 100 =
   until
   ;
: Test_Rx
   R.RX
   begin
      R_RX_PAYLOAD
      10 0 do 
         emit
      loop
      cr \ should see Hello World on console 100 times
   again
   ;
: R.Setup
   PO_width RX_PW_P0 R! \ effectively enables pipe 0
   ;
