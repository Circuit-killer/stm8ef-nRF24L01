\ temporary dependencies

#require ]B!
#require ]C!

\ definitions *********************************************

\res MCU: STM8S103
\res export BIT0 BIT1 BIT2 BIT3 BIT4 BIT5 BIT6 BIT7
\res export SPI_CR1 SPI_CR2 SPI_DR SPI_SR
\res export PC_ODR PC_DDR PC_CR1 PC_CR2
\res export PD_ODR PD_DDR PD_CR1 PD_CR2

\ nrf24L01+ registers and commands
$00 CONSTANT R.CONFIG
$04 CONSTANT R.SETUP_RETR
$05 CONSTANT R.RF_CH
$06 CONSTANT R.RF_SETUP
$1C CONSTANT R.DYNPD
$1D CONSTANT R.FEATURE
$E1 CONSTANT FLUSH_TX
$E2 CONSTANT FLUSH_RX

NVM

\ nrf24L01+ registers and commands
$07 CONSTANT R.STATUS
$0A CONSTANT R.RX_ADDR_P0
$10 CONSTANT R.TX_ADDR
$11 CONSTANT R.RX_PW_P0
$61 CONSTANT R_RX_PAYLOAD
$A0 CONSTANT W_TX_PAYLOAD
$A8 CONSTANT W_ACK_PAYLOAD

\ SPI Setup and Commands***********************************

\ Init and enable SPI
\ 76543210
\ 0         MSB first
\  0        SPI disabled
\   111     Baud rate control 111=fmaster/256
\      1    STM8 is master
\       0   SCK to 0 when idle
\        0  First clock transition is when data is read
\ 00111100  = $3C

: SPIon  ( -- )
   [ $0C SPI_CR1 ]C!  \ works for me with 4MHz SPI clock
   [ $03 SPI_CR2 ]C!  \ no NSS, FD, no CRC, software slave, master
   [ $4C SPI_CR1 ]C!  \ enable SPI
   ;

: SPI  ( c -- c )
   [  $E601 ,                 \ LD   A,(1,X)
      $C7 C,  SPI_DR ,        \ LD   SPI_DR,A
      $7201 , SPI_SR , $FB C, \ BTJF SPI_SR,#SPIRXNE_WAIT (0)
      $C6 C,  SPI_DR ,        \ LD   A,SPI_DR
      $E701 ,                 \ LD   (1,X),A
      $7F C, ]                \ CLR  (X)
   ;

\ timing **************************************************

: *10us  ( n -- )  \  delay n * 10us
   1- FOR [
      $A62B ,    \      LD    A,#42
      $4A  C,    \ 1$:  DEC   A
      $26FD ,    \      JRNE  1$
   ] NEXT
   ;

: ms  ( n -- )  \  delay n ms
   1- FOR 100 *10us NEXT
   ;

\ bit and variable manipulation ***************************

: >LOW  ( c1 bitn ---- c2 )  \ set bitn low
   NOT AND
   ;

: >HIGH  ( c1 bitn ---- c2 )  \ set bitn high
   OR
   ;

: setup_pins  ( -- )
   \ Port C inputs are floating, no interrupts enabled
   [ $0C ( 0b00001100 ) PD_DDR ]C!  \ Port D outputs
   [ $0C                PD_CR1 ]C!  \ set up as push pull outputs
   [ $0C                PD_CR2 ]C!  \ fast mode outputs
   [ $60 ( 0b01100000 ) PC_DDR ]C!  \ port C outputs
   [ $60                PC_CR1 ]C!  \ set as push pull outputs
   [ $60                PC_CR2 ]C!  \ set as fast mode outputs
   ;

: _CE.LOW  ( -- )
   [ 0 PD_ODR _CE ]B!
   ;

: _CSN.LOW  ( -- )
   [ 0 PD_ODR _CSN ]B!
   ;

: _CSN.High  ( -- )
   [ 1 PD_ODR _CSN ]B!
   ;

\ talk to nRF24L01+ ***************************************

: (nrf@!)  ( c1 ---- )
   _CSN.LOW SPI  DROP
   ;

: nRF@n  ( c2 c1 --- cN..C1 )  \ read c2 bytes
   (nrf@!)
   0 DO
      -1 SPI
   LOOP
   _CSN.High
   ;

: nRF@1  ( c1 --- c2 )  \ fetch the contents of register c1
   1 SWAP nRF@n
   ;

\ Config register operations

: nRF!_  ( c1 A1 --- c1 )  \ factored starting seq
   $20 OR
   (nrf@!) \ calling word must set _CSN high when finished sending data
   ;

: nRF!0  ( c1 --- )  \ send command c1
   nRF!_
   _CSN.HIGH
   ;

: nRF!n  ( cn....c1 a1 n --- )  \ write to nRF24 register A1 n bytes
   SWAP nRF!_ \ sends address to write to
   0 DO
      SPI DROP
   LOOP
   _CSN.HIGH
   ;

: nRF!1  ( c a -- )
   1 nRF!n
   ;

: nRF!5  ( c5....c1 a -- )
   5 nRF!n
   ;

: IRQ@AND  ( c1 ---- f1 )
   \ Get Interrupts then AND with c1
   R.STATUS _CSN.LOW SPI _CSN.HIGH AND   \ cant use nRF@1 since it toggles _CE
   ;

: TEST_INT  ( c1 --- f1 )
   DUP BIT4 AND IF ." Max retries cleared" CR -1 ELSE 0 THEN ( --- c1 f1 )
   OVER BIT5 AND IF ." Tx data sent" CR -1 ELSE 0 THEN OR
   SWAP BIT6 AND IF ." Rx data ready" CR -1 ELSE 0 THEN OR
   ;

: CLR_INT  ( -- )
   R.STATUS nRF@1
   TEST_INT IF
     $70  R.STATUS nRF!1 \ 0b01110000
   THEN
   ;

: RX_DR?  ( -- f )  BIT6 IRQ@AND ;

: TX_DS?  ( -- f )  BIT5 IRQ@AND ;

: MAX_RT?  ( -- f )  BIT4 IRQ@AND ;

: RX_P_NO  ( -- c )  $0E IRQ@AND ; \ 0b00001110

: TX_Full?  ( -- f )  BIT0 IRQ@AND ;


\ lets setup nrf24L01+ how we want ************************

: SetAddress  ( -- )  \ LSB first
   $E7 $D6 $C5 $B4 $A3 R.RX_ADDR_P0  nRF!5
   $E7 $D6 $C5 $B4 $A3 R.TX_ADDR     nRF!5
   ;

: SetPL_width  ( c -- )  \ set bytes in rx payload
   R.RX_PW_P0  nRF!1
   ;

: R@Config  ( -- c1 )  \ fetch config reg
   R.CONFIG  nRF@1
   ;

: R!Config  ( c1 -- )  \ write C1 to config reg
   R.CONFIG  nRF!1
   ;

: TX.PWR-18  ( -- )  \ SEt to -18dBm output and 250kbps
   [ $0 BIT5 >HIGH ] LITERAL R.RF_SETUP nRF!1
   ;

: SetRetry  ( -- )  \ ARD: retransmit delay, ARC: retries
   ( ARD: 8*250us, ARC: 15* ) $8F R.SETUP_RETR nRF!1
   ;

: myChannel  ( -- ) \ set channel (fix, for now)
  $70 R.RF_CH nRF!1
  ;

: >Standby1  ( -- )  \ enter Standby state
   _CE.LOW   2 ms
   R@CONFIG
   [ BIT1 ( PWR_UP ) BIT2 ( CRC0 ) OR ] LITERAL >HIGH
   R!CONFIG
   ;

: PWR.Dn  ( -- )
   _CE.LOW R@Config  BIT1 >LOW R!Config
   ;

: FlushRx  ( -- )
   $E2 nRF!0
   ;

: FlushTx  ( -- )
   $E1 nRF!0
   ;

: _CE.HD  ( -- )
   \ set CE high and pause
   [ 1 PD_ODR _CE ]B!   13 *10us
   ;

: Set.RX  ( -- )
   \ set as a receiver
   R@Config BIT0 >HIGH   R!CONFIG
   ;

: Set.TX  ( -- )  \  set as a transmitter
   R@Config BIT0 >LOW  R!CONFIG
   ;

: nRF24Init  ( -- )  \ stuff we must do after a reset or power on
   setup_pins    \ set up pins and SPI (RST)
   _CSN.HIGH SPIOn
   100 ms        \ delay after power-on reset (spec fig. 3)
   >Standby1
   SetAddress
   TX.PWR-18
   FlushRx FlushTx CLR_INT
   SetRetry
   myChannel
   ." Device reset" cr
   ;

: (RX)  ( -- )  \ setup as primary receiver
   nRF24Init      \ setup and go to Standby1
   P0_WIDTH SetPL_width   \ effectively enables Pipe0
   Set.RX         \ Will be a RX
   ;

: (TX)  ( -- )  \ setup as primary transmitter
   nRF24Init      \ setup and go to Standby1
   Set.TX         \ enter TX mode
   ;

: b>nRF ( a n CMD -- s )  \  copy n chars from a to payload register on nRF24
   _CSN.LOW SPI ( a n -- s ) >R
   0 DO
      DUP C@ SPI DROP 1+
   LOOP _CSN.HIGH
   ( a -- ) DROP R> ( -- s )
   ;

: nRF>b ( b c CMD -- s ) \  copy count c bytes from payload register on nRF24 to buffer b
   \  return nRF24 STATUS s
   _CSN.LOW SPI ( a n s -- ) >R
   0 DO
      -1 SPI OVER C! 1+
   LOOP  _CSN.HIGH
   ( -- a ) DROP R> ( -- s )
   ;
: b>tx ( b c -- s ) 
    \  copy c bytes from buffer b to TX payload and send, return STATUS
    W_TX_PAYLOAD b>nRF
   _CE.HD _CE.LOW  \  10us minimum, using 130uS
;
: b>ack ( b c p -- s )
    \  copy c bytes payload from buffer b to p ACK pipe p, return STATUS
    W_ACK_PAYLOAD OR b>nrf
;
: rx>b ( b c -- s )
    \  copy c bytes payload to buffer b, return STATUS
    R_RX_PAYLOAD nrf>b
    ;
: PAYLOAD.TX  ( -- )  \ send n bytes as set by P0_width
   mybuff P0_WIDTH b>tx DROP
   ;

RAM
